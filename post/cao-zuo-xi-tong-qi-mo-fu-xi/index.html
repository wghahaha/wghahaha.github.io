<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>操作系统期末复习 | white0123</title>
<link rel="shortcut icon" href="https://wghahaha.github.io/favicon.ico?v=1714286336284">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://wghahaha.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="操作系统期末复习 | white0123 - Atom Feed" href="https://wghahaha.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="操作系统期末复习
第1章   操作系统引论


什么是操作系统？
操作系统是管理计算机软、硬 件资源的软件，控制和协调计算处 理活动，提供用户接口


操作系统的主要功能
处理机管理功能    文件管理功能    内存管理功能   接口管理..." />
    <meta name="keywords" content="学校" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://wghahaha.github.io">
  <img class="avatar" src="https://wghahaha.github.io/images/avatar.png?v=1714286336284" alt="">
  </a>
  <h1 class="site-title">
    white0123
  </h1>
  <p class="site-description">
    永远保持第一天接触网络安全的热情
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              操作系统期末复习
            </h2>
            <div class="post-info">
              <span>
                2023-01-03
              </span>
              <span>
                10 min read
              </span>
              
                <a href="https://wghahaha.github.io/tag/ABT_a6tXX/" class="post-tag">
                  # 学校
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h4 id="操作系统期末复习">操作系统期末复习</h4>
<h5 id="第1章-操作系统引论"><strong>第1章</strong>   <strong>操作系统引论</strong></h5>
<ol>
<li>
<p><strong><mark>什么是操作系统？</mark></strong></p>
<p>操作系统是管理计算机软、硬 件资源的软件，控制和协调计算处 理活动，提供用户接口</p>
</li>
<li>
<p><mark><strong>操作系统的主要功能</strong></mark></p>
<p>处理机管理功能    文件管理功能    内存管理功能   <mark>接口管理功能</mark>  设备管理功能  <mark>现代OS的新功能</mark><a href="https://imgse.com/i/zvXOLq"><img src="https://s1.ax1x.com/2022/12/25/zvXOLq.png" alt="zvXOLq.png" loading="lazy"></a></p>
</li>
<li>
<p><strong><mark>什么是原语？</mark></strong></p>
<p>原语是对操作系统核心数据结构（进程表、进程控制块、设备控制块、 文件控制块）进行修改操作的程序。</p>
<figure data-type="image" tabindex="1"><a href="https://imgse.com/i/zvjpYF"><img src="https://s1.ax1x.com/2022/12/25/zvjpYF.png" alt="zvjpYF.png" loading="lazy"></a></figure>
</li>
<li>
<p><mark><strong>用户态和内核态</strong></mark></p>
<figure data-type="image" tabindex="2"><a href="https://imgse.com/i/zvjPSJ"><img src="https://s1.ax1x.com/2022/12/25/zvjPSJ.png" alt="zvjPSJ.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="3"><a href="https://imgse.com/i/zvjFyR"><img src="https://s1.ax1x.com/2022/12/25/zvjFyR.png" alt="zvjFyR.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="4"><a href="https://imgse.com/i/zvjmFO"><img src="https://s1.ax1x.com/2022/12/25/zvjmFO.png" alt="zvjmFO.png" loading="lazy"></a></figure>
</li>
<li>
<p><strong><mark>什么是系统调用</mark></strong></p>
</li>
</ol>
<p><strong>应用程序不能直接访问计算机的软硬件资源。系统调用是应用程序请求操作系统内 核程序执行、对软硬件资源进行操作的接口。 系统调用过程的本质就是中断调用过程，其实现方式包括显示方式和隐式方式两种。</strong></p>
<h5 id="第2章-进程的描述与控制"><strong>第2章</strong>   <strong>进程的描述与控制</strong></h5>
<p><strong><mark>§ 什么是进程？什么是线程？两者的区别</mark></strong></p>
<p><strong>进程的定义</strong></p>
<ul>
<li>
<p>进程是程序的一次执行</p>
</li>
<li>
<p>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</p>
</li>
<li>
<p>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调 度的一个独立单位。</p>
<p><strong>可以简单理解为：进程就是执行中的程序</strong></p>
</li>
</ul>
<p><strong>线程的概念</strong></p>
<p>概念一：线程（thread）是进程内一个相对独立的、可调度的执行单元 （执行路径、执行轨迹、执行代码段、执行流）。</p>
<p>概念二：线程是一种轻量级进程。（和进程比较，负重相对轻）</p>
<p>​         <strong>对概念一的理解</strong></p>
<ul>
<li>
<p>线程是一个进程内的一段代码；</p>
</li>
<li>
<p>独立运行、可调度，即多个线程独立并发运行。</p>
</li>
</ul>
<figure data-type="image" tabindex="5"><a href="https://imgse.com/i/zvjo0x"><img src="https://s1.ax1x.com/2022/12/25/zvjo0x.png" alt="zvjo0x.png" loading="lazy"></a></figure>
<p><strong>线程和进程的区别与联系</strong></p>
<p>（1）从CPU调度和资源分配角度。进程是CPU调度单位，也是资源分配 单位；线程是进程内部最小的CPU调度单位；除了线程运行所需的私有资源 （栈区、程序计数器以及线程运行使用的寄存器），系统不给线程分配其他资 源，线程继承父进程资源（变量、堆区、文件、端口等）。</p>
<p>（2）从安全性角度。进程拥有独立的地址空间，只能访问各自空间内的 数据；多个线程使用父进程的地址空间，直接访问父进程数据、资源。</p>
<p>（3）从系统开销角度。进程间通信、进程状态转换开销大；线程间通信、 线程状态转换开销相对小。</p>
<p><strong><mark>§  什么是进程控制块？</mark></strong></p>
<p>操作系统为每个进程创建一个进程控制块，通过进程控制块感知、控 制、管理进程。</p>
<p>进程控制块PCB (Process Control Block)，就是描述进程在各个不 同时期所处的状态以及进程与其他进程、系统资源间关系的数据块（数 据表）。</p>
<p>详细讲解在第2讲第一部分PPT的25页开始。</p>
<p><strong><mark>§  进程在三个基本状态之间转换的典型原因</mark></strong></p>
<p>​      首先需要知道三种基本状态分别是 <mark>运行</mark> <mark>就绪</mark>  <mark>等待</mark></p>
<figure data-type="image" tabindex="6"><a href="https://imgse.com/i/zvvtD1"><img src="https://s1.ax1x.com/2022/12/25/zvvtD1.png" alt="zvvtD1.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="7"><a href="https://imgse.com/i/zvvBCD"><img src="https://s1.ax1x.com/2022/12/25/zvvBCD.png" alt="zvvBCD.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="8"><a href="https://imgse.com/i/zvvrgH"><img src="https://s1.ax1x.com/2022/12/25/zvvrgH.png" alt="zvvrgH.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="9"><a href="https://imgse.com/i/zvvcDI"><img src="https://s1.ax1x.com/2022/12/25/zvvcDI.png" alt="zvvcDI.png" loading="lazy"></a></figure>
<p>详细讲解在第二讲第一部分PPT的31页</p>
<p><strong><mark>§  熟悉主要的进程间通信</mark></strong></p>
<figure data-type="image" tabindex="10"><a href="https://imgse.com/i/zvxCrR"><img src="https://s1.ax1x.com/2022/12/25/zvxCrR.png" alt="zvxCrR.png" loading="lazy"></a></figure>
<p>这部分主要是熟悉理解，不是什么问题回答。只有自己去熟悉。</p>
<p>详细讲解在第二讲的第二部分PPT。（基本上整个PPT都是）</p>
<h5 id="第3章-处理机调度与死锁"><strong>第3章</strong>   <strong>处理机调度与死锁</strong></h5>
<p><mark><strong>§  熟悉主要的进程调度算法</strong></mark></p>
<ul>
<li>
<p>多级队列调度算法</p>
</li>
<li>
<p>时间片轮转调度算法(RR)</p>
</li>
<li>
<p>优先权调度算法(PS)</p>
</li>
<li>
<p>多级反馈队列调度算法</p>
</li>
</ul>
<p>详细讲解在第4讲PPT的24页开始。</p>
<p><mark><strong>§  什么死锁？产生死锁的四个必要条件</strong></mark></p>
<p>--教材定义：如果一组并发进程中的每一个进程都在等待仅由该进程中的其他进程 才能引发的事件发生，那么改组进程是死锁的。</p>
<p><strong>一组并发运行的进程/线程间由于竞争资源而导致相互制约，以至于无法继续运行的 局面（僵局），就是死锁。</strong></p>
<p>​       <strong>产生死锁的四个必要条件</strong></p>
<ol>
<li>
<p><strong>互斥条件</strong></p>
<p>一段时间内某 资源只能被一 个进程占用。</p>
</li>
<li>
<p><strong>请求和保持条件</strong></p>
<p>一个至少占有一 个资源的进程， 等待获得额外的 由其他进程所持 有的资源。</p>
</li>
<li>
<p><strong>不可抢占</strong></p>
<p>一个资源只 有当持有它 的进程完成 任务后，自 由的释放。</p>
</li>
<li>
<p><strong>循环等待</strong></p>
<p>等待资源的进程之间存在 环 {P0, P1, …, Pn} 。</p>
<p>P0 等待P1占有的资源, P1 等待P2占有的资源, …, Pn– 1等待Pn占有的资源, P0等 待Pn占有的资源。</p>
</li>
</ol>
<p>这部分的讲解在第四讲的45页PPT开始。</p>
<p><mark><strong>§  列出2种死锁预防方法和1种死锁避免方法</strong></mark></p>
<p><strong>死锁预防</strong></p>
<ol>
<li>
<p><strong>一次性分配资源法</strong></p>
<ul>
<li>特点：进程一次性占有整个运行期间的全部资源（其中，有些资源实在 运行初期或运行快结束时才会使用）</li>
<li>优点：简单、易行、安全</li>
<li>缺点：资源利用率低，可能出现饥饿</li>
</ul>
</li>
<li>
<p>资源释放法</p>
<p>如果一个进程的申请没有实现，它要释放所有占有的资源</p>
</li>
<li>
<p>有序分配法</p>
<p>为资源指定唯一编号，进程需要依次申请所需资源。如下图所示： 必须先申请并锁定账户A，才能请求锁定账户B。</p>
</li>
</ol>
<figure data-type="image" tabindex="11"><a href="https://imgse.com/i/zvzG01"><img src="https://s1.ax1x.com/2022/12/25/zvzG01.png" alt="zvzG01.png" loading="lazy"></a></figure>
<p><mark><strong>死锁避免</strong></mark></p>
<p><strong>银行家算法</strong></p>
<p>基本思想</p>
<p>分配资源之前，预判断系统是否是安全的。也就是模 拟分配资源之后，系统是否存在进程安全序列； 若是存在，才分配。每分配一次资源就测试一次是否 安全，不是资源全部就位后才测试</p>
<p>这部分的讲解在第四讲PPT的64页开始。</p>
<p><mark><strong>§  对于时间片轮转算法，如何计算平均等待时间，如何计算平均响应时间</strong></mark></p>
<p>关于时间片轮转调度算法有一篇博客，我感觉讲的不错 https://blog.51cto.com/u_14223591/5481746</p>
<p>然后我们现在根据PPT上的题进行分析一下。</p>
<figure data-type="image" tabindex="12"><a href="https://imgse.com/i/zxSVjH"><img src="https://s1.ax1x.com/2022/12/25/zxSVjH.png" alt="zxSVjH.png" loading="lazy"></a></figure>
<p><strong>平均等待时间</strong></p>
<p>首先我们来计算平均等待时间。</p>
<p>我们首先需要根据进程画出次序图。（需要考虑时间片，进程开始的时间，以及优先级等方面。）</p>
<p>他这里直接给出了次序图，就比较简单了直接看图就可以了。</p>
<p>首先计算P1的等待时间：可以由次序图看出，P1是第一个执行的进程，所以最开始等待为0。但是我们可以看到P1的运行时间为23ms这里只有20ms就切换到了P2了，直到第77ms才切换为P1。然后这里执行了3ms就结束了。所以P1的等待时间为 77-20=57ms</p>
<p>然后计算P2的等待时间：P2的运行时间只有17ms小于20ms在一个时间片中是可以运行完的。所以我们看到在第20ms的时候执行p2在第37ms的时候执行p3同时结束了p2。所以p2的等待时间为 20ms</p>
<p>剩下的两个就不详细说了，思路就是和上面的一样。最后可以算出 P3和P4的等待时间。</p>
<p>平均等待时间就等于总的等待时间相加然后除以进程数量</p>
<p><strong>平均响应时间</strong></p>
<p>响应时间就等于第一段等待时间。</p>
<p>P1是直接执行所以响应时间为0</p>
<p>P2是在20ms第一次执行，所以响应时间为20ms</p>
<p>p3是在37ms第一次执行，所以响应时间为37ms</p>
<p>p4是在57ms第一次执行，所以响应时间为57ms</p>
<p>平均响应时间就等于总的响应时间相加然后除以进程数量</p>
<p><mark><strong>§  运用银行家算法，检查或推导资源分配题</strong></mark></p>
<p>这部分的思维我感觉主要是用到了遍历，然后根据可用资源如何才可以满足进程需要的思路，详细就不说了可以根据网上的博客进行学习。</p>
<p>推荐博客 https://blog.csdn.net/weixin_42711189/article/details/115485594</p>
<p>详细讲解在第四讲PPT的64页开始。</p>
<h5 id="第4章-进程同步"><strong>第4章</strong>   <strong>进程同步</strong></h5>
<p><mark><strong>§  什么是临界资源？</strong></mark></p>
<p>一次仅允许一个进程/线程使用的资源被称为临界资源，或独享资源、互 斥资源。 硬件资源：如输入机、打印机等； 软件资源：有的公用变量、文件等</p>
<p><mark><strong>§  什么是进程互斥？</strong></mark></p>
<p>在操作系统中，当某一进程正在进入临界区访问某一临界资源 时，不允许其他进程访问该临界资源。否则，会发生无法估计的错 误。进程间的这种制约关系成为进程互斥。</p>
<p><mark><strong>§  什么是进程同步？</strong></mark></p>
<p>**所谓同步，是指多个相互合作的进程/线程，在一些关键点上 可能需要相互等待或相互交换信息，这种互相制约的关系称为进程 /线程同步。 **</p>
<p><strong>通俗地说，多个进程在执行上要有先后次序，一个进程要等另 一伙伴进程提供消息（执行结果）。未获得消息之前，进程处于等 待状态，获得消息后才能被唤醒进入就绪状态</strong></p>
<p><mark><strong>§  运用信号量P、V操作，实现多个进程对公共变量Q的互斥使用</strong></mark></p>
<p>详细讲解在第三讲PPT的38页开始。</p>
<p>P操作：资源监测。需要访问临界资源的进程发出检测信号量的操作， 监测是否能够进入临界区访问临界资源。</p>
<p>V操作：资源释放。访问完临界资源的进程，退出临界区前释放临界资 源，通知等待进程可以使用临界资源。</p>
<p>实现思路</p>
<ul>
<li>分析并发进程的关键活动，划分临界区</li>
<li>设置互斥信号量mutex，初值为1</li>
<li>在临界区之前执行P(mutex)</li>
<li>在临界区之后执行V(mutex)</li>
<li>P、V操作必须成对出现。缺少P操作不能保证临界资源的互斥访问；缺少V操作会导致资源永不被释放，等待进程永远不会被唤醒</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0">操作系统期末复习</a>
<ul>
<li><a href="#%E7%AC%AC1%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA"><strong>第1章</strong>   <strong>操作系统引论</strong></a></li>
<li><a href="#%E7%AC%AC2%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6"><strong>第2章</strong>   <strong>进程的描述与控制</strong></a></li>
<li><a href="#%E7%AC%AC3%E7%AB%A0-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81"><strong>第3章</strong>   <strong>处理机调度与死锁</strong></a></li>
<li><a href="#%E7%AC%AC4%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><strong>第4章</strong>   <strong>进程同步</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '60a6742bb0cdc1129286',
    clientSecret: '2c932a185a0c37b7924302f1ab242ffd3c186641',
    repo: 'wghahaha.github.io',
    owner: 'wghahaha',
    admin: ['wghahaha'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  <div>
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	<span id="busuanzi_container_site_uv" style='display:none'>总访客人数量<span id="busuanzi_value_site_uv"></span>次</span>
	<span id="busuanzi_container_site_pv" style='display:none'>本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</div>
  <a class="rss" href="https://wghahaha.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
